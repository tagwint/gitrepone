# functions gathered here to be sourced at once
# vim: ft=sh
# =========

# svn wrapper to not keep password savedd
function svu ()
{
  local _arg
  local _serv
  local _auth
  local _urlserv
  local _wcserv
  ## <<< must be local, otherwise they mess up from previous runs !!!
  command svn --version >/dev/null || { echo "Subversion client svn seem not to be installed here: svn" ; return 1; }

  # test if cwd is a working copy of some repo
  svn info >/dev/null 2>&1 &&  _wcserv=$(svn info | grep ^URL | sed 's|^.*http.*://||;s|/.*$||g' 2>/dev/null)
  if [[ -z ${_wcserv} ]] # no, it does not look like a wrk copy of some repo
  then 
    echo "INFO: No working copy here, in $(pwd)"
  else 
    echo "INFO: Working copy from ${_wcserv} detected "
  fi

  # test if the argument contains some http* url
  # echo "Checking arg against valid url ..."
  [[ "$@" =~ http.*://([^/]*)/.*$ ]] && _urlserv=${BASH_REMATCH[1]}
  if [[ -z ${_urlserv} ]] # no server in args 
  then 
    echo "INFO: No server name in ${@}"
  else 
    echo "INFO: Server name ${_urlserv} detected "
  fi

  # none of wrk copy and url
  if [[ "${_wcserv:-NOWCSVR}" == "NOWCSVR" ]] && [[ "${_urlserv:-NOURLSVR}" == "NOURLSVR" ]]
  then 
    echo "ERROR: Neither a working copy is here: $(pwd)"
    echo "_____: Nor url provided in args"
    return 1;
  fi

  # not a wrk but just url
  if [[ "${_wcserv:-NOWCSVR}" == "NOWCSVR" ]] && [[ ! "${_urlserv:-NOURLSVR}" == "NOURLSVR" ]]
  then 
    _serv=${_urlserv}
  fi

  # just wrk
  if [[ ! "${_wcserv:-NOWCSVR}" == "NOWCSVR" ]] && [[ "${_urlserv:-NOURLSVR}" == "NOURLSVR" ]]
  then 
    _serv=${_wcserv}
  fi

  # both  wrk and url relate to the same server
  if [[ "${_wcserv:-NOWCSVR}" == "${_urlserv:-NOURLSVR}" ]]
  then 
    _serv=${_wcserv}
  fi

  # both wrk copy and url are there but mismatch
  if [[ ! "${_wcserv:-NOWCSVR}" == "NOWCSVR" ]] && [[ ! "${_urlserv:-NOURLSVR}" == "NOURLSVR" ]] && [[ ! ${_wcserv} == ${_urlserv} ]]
  then
    echo "ERROR: Working copy mismatches requested url:"
    echo "WC:${_wcserv}"
    echo "URL:${_urlserv} "
    return 1;
  fi

  case ${_serv:-NONE} in
      svn.${CORPDOMAIN})
          # _auth="--username ${CORPUSER} --password $(KRPWD ${CORPUSER}@${CORPDOMAIN}) " 
          _pw=$(KRPWDE ${CORPUSER}@${CORPDOMAIN}) &&  _auth="--password ${_pw}"
      ;;
      github.com) 
          _pw=$(KRPWDE githubsvn) && _auth="--password  ${_pw} " 
      ;;
      NONE) # should not get here
         echo "ERROR: Neither working copy here, nor an url in args, nothing doing " ; return 1 
      ;;
      *)
         echo "INFO: Unknown server for working copy, failing back to default svn"
          
  esac 
  echo "INFO: Server to deal with detected: ${_serv}"
  _arg="$@"
  # echo ARG: ${_arg} 
  echo -n "INFO: Args passed:"; printf '[%q] ' "$@"
  echo
  echo =========
  if [[ ! -z "${_arg}" ]] 
  then
    [[ "${_auth:-none}" == "none" ]] &&  { echo "WARN: Auth for $_serv could not be obtained"; }
    svn "$@"  ${_auth}
  else
    svn "$@"
  fi
}

function vxyn ()
{
  local lhint=${1:-'Are you sure? (y/n)'}
  local REPLY=N
  local lRetVAR=${2:-VXRET}

  read -p "$lhint"  
  while [ ! "$REPLY" == "y" -a ! "$REPLY" == "n" ]
  do 
    read -p "Enter (y/n)?"  
  done
  if [ "$REPLY" == "y" ] 
  then
    echo yes
    return 0
  else 
    echo no
    return 1
  fi
# 0 means yes (success), 1 - no
} 

vagcd () {
  local sel
  sel=$(vagrant global-status | grep '^.......  ' | grep -v '^id '|fzf|awk '{print $NF}')
  [[ -n "$sel" ]] && cd "$sel" && ls 
}

function vagsnap () {
  local p n s r o SSN bpref src dst vagst
  [ -f Vagrantfile ]              || { echo No Vagrantfile in this dir; return 1; }
  vagst=$(vagrant status  | egrep  '\(virtualbox\)|\(lxc\)')
  [[ -n "$vagst" ]] || { echo Neither vbox nor lxc ; return 1; } 
  p=$({ egrep  '\(virtualbox\)|\(lxc\)' | awk '{print $NF}' | tr -d '()' ; }<<<"${vagst}")
  case $p in
    virtualbox)
        vagrant snapshot ${1:-list}
        ;;
    lxc)
        n=$({ egrep  '\(virtualbox\)|\(lxc\)' | awk '{print $1}' ; }<<<"${vagst}" )
        s=$({ egrep  '\(virtualbox\)|\(lxc\)' | awk '{print $2}' ; }<<<"${vagst}" )
        bpref=$(basename $(pwd))
        o=${1:-list}
        if [[ !  "${o}" == "list" ]]; then
          [[ ${s} == "running" ]] && { echo $n is running, you may want to stop it first; return 1; }
        fi;
        r=$(sudo find -L /var/lib/lxc  -maxdepth 1 -type d -type d  -regex "^/var/lib/lxc/${bpref}_${n}.*$")
        echo Content of $r dir:
        sudo find -L $r -maxdepth 1 -type d  -name rootfs\* | awk -F/ '{ print $NF }'
        case $o in
          save)
             SSN=${2:-"bak"}
             echo Saving ${SSN} snapshot
             dst=${r}/rootfs_${SSN}
             echo Saving ...
             vxyn "rsync -a --delete ${r}/rootfs/ ${dst}/ Sure to continue? " || return 1;
             echo No Progess bar here ...
             sudo  rsync -a --delete ${r}/rootfs/ ${dst}/ && echo Save Completed OK
             ;;
          restore)
             SSN=${2:-"NONE"}
             if [[ ! "$SSN" == "NONE"  ]] ; then
               sudo ls ${r}/rootfs_${SSN} || { echo NO ${SSN} is there; return 1; }
               src=${r}/rootfs_${SSN}
             else 
               src=$(sudo find $r -maxdepth 1 -type d -regex "^.*/rootfs.+$" | fzf)
             fi
             echo Restoring ${SSN} snapshot
             dst=${r}/rootfs
             vxyn "rsync -a --delete ${src}/ ${dst}/  Sure to continue? " || return 1;
             echo Restoring ...
             echo No Progess bar here ...
             sudo  rsync -a --delete ${src}/ ${dst}/ && echo Restore Completed OK
             ;;
          list)
             ## "Listing done above"
             ;;
          *)
             echo "Unkonwn operation VM type $o"
             ;;
        esac
        ;;
    *)
        echo "Unkonwn vag VM type $p"
        return 1
        ;;
  esac
}

svfm () {
  local c
  c=$(which vfm)
  sudo $c $*
}

lxa () {
  local sel
  sel=$(sudo lxc-ls -f | grep ' RUNNIN' | fzf | awk '{print $1}')
  [[ -n "$sel" ]] && sudo lxc-attach -n "$sel" 
}
